def split_data(df, split=.25, target='col'):
    X = df.loc[:, df.columns != target]
    y = df.loc[:, target]

    X_train_temp, X_test, y_train_temp, y_test = train_test_split(X, y, test_size=0.2)
    X_train, X_val, y_train, y_val = train_test_split(X_train_temp, y_train_temp, test_size=0.2)
    return X_train, y_train, X_val, y_val, X_test, y_test

X_train, y_train, X_val, y_val, X_test, y_test = split_data(df)

def plot_compare(preds, y_test, lbl='1', mse=None, mae=None, zoom=None):
    title = lbl.replace('_', ' ')
    title = title.title()
    lbl = lbl.replace(' ', '_')
    lbl = lbl.lower()
    plt.figure(figsize = [15, 5])
    
    h_axis = np.linspace(0, y_test.shape[0], y_test.shape[0])
    plt.plot(h_axis, preds, 'ro', markersize=3, markerfacecolor=(1, 1, 0, 0.8))
    plt.plot(h_axis, y_test, 'bo', markersize=3, markerfacecolor=(1, .5, 0, 0.8))
    plt.title(title + ' Prediction and Label Values')
    plt.ylabel('Yards / 100')
    plt.ylim([-.2, .8])
    
    text_x = 2400 - 100
    if zoom:
        plt.xlim(zoom)
        text_x = zoom[1] - 100
    else:
        plt.xlim([0, len(h_axis)])

    if mse: plt.text( text_x, .72, f'MSE Loss: {round(mse, 6)}', fontsize = 10)
    if mae: plt.text( text_x, .64, f'MAE Loss: {round(mae, 6)}', fontsize = 10)
    
    plt.xlabel('Test Index')
    plt.savefig('pred_and_label_' + lbl + '.png')
    plt.show()

    dif = np.subtract(preds, y_test)
    dif = np.multiply(dif, 100)
    plt.plot(h_axis, dif, 'ko', markersize=2)
    plt.title(title + ' Preliminary Difference Between Prediction and Label')
    plt.ylabel('Yards')
    plt.xlabel('Test Index')
    plt.ylim([-60, 60])
        
    text_x = 2400 - 100
    if zoom:
        plt.xlim(zoom)
        text_x = zoom[1] - 100
    else:
        plt.xlim([0, len(h_axis)])

    if mse: plt.text( text_x, 85, f'MSE Loss: {round(mse, 6)}', fontsize = 10)
    if mae: plt.text( text_x, 80, f'MAE Loss: {round(mae, 6)}', fontsize = 10)
    
        
    plt.savefig('difference_' + lbl + '.png')
    plt.show()

###############
def generate_3d_data(m, w1=0.1, w2=0.3, noise=0.1):
    """create some 3d data with noise"""
    angles = np.random.rand(m) * 3 * np.pi / 2 - 0.5
    data = np.empty((m, 3))
    data[:, 0] = np.cos(angles) + np.sin(angles)/2 + noise * np.random.randn(m) / 2
    data[:, 1] = np.sin(angles) * 0.7 + noise * np.random.randn(m) / 2
    data[:, 2] = data[:, 0] * w1 + data[:, 1] * w2 + noise * np.random.randn(m)
    return data

X_train = generate_3d_data(1000)
X_train = X_train - X_train.mean(axis=0, keepdims=0)

ax = plt.axes(projection="3d")
ax.scatter3D(X_train[:,0], X_train[:,1], X_train[:,2], c=X_train[:,2], cmap="viridis")
##############
encoder2 = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[28, 28]),
    keras.layers.Dense(100, activation="selu"),
    keras.layers.Dense(30, activation="selu"),
])

decoder2 = keras.models.Sequential([
    # keras.layers.Dense(30, input_shape=([784]), activation="selu"),
    keras.layers.Dense(30, activation="selu"),
    keras.layers.Dense(100, activation="selu"),                               
    keras.layers.Dense(784, activation="selu"),
    keras.layers.Reshape([28, 28])
])
autoencoder2 = keras.models.Sequential([encoder2, decoder2])
sgd = keras.optimizers.SGD(lr=1)
autoencoder2.compile(loss="mse", optimizer=sgd, metrics=["accuracy"])
autoencoder2.fit(X_train, X_train, validation_data=(X_valid, X_valid), epochs=10)
###############
denoising_encoder = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[28, 28]),
    keras.layers.GaussianNoise(0.2),
    keras.layers.Dense(100, activation="selu"),
    keras.layers.Dense(30, activation="selu")
])
denoising_decoder = keras.models.Sequential([
    keras.layers.Dense(100, activation="selu", input_shape=[30]),
    keras.layers.Dense(28 * 28, activation="sigmoid"),
    keras.layers.Reshape([28, 28])
])

denoising_ae = keras.models.Sequential([denoising_encoder, denoising_decoder])
SGD = keras.optimizers.SGD(lr=1.0)
denoising_ae.compile(optimizer=SGD, loss="binary_crossentropy", metrics=['accuracy'])
history = denoising_ae.fit(X_train, X_train, validation_data=[X_valid, X_valid], epochs=10)
##############
def plot_multiple_images(images, n_cols=None):
    n_cols = n_cols or len(images)
    n_rows = (len(images) - 1) // n_cols + 1
    if images.shape[-1] == 1:
        images = np.squeeze(images, axis=-1)
    plt.figure(figsize=(n_cols, n_rows))
    for index, image in enumerate(images):
        plt.subplot(n_rows, n_cols, index + 1)
        plt.imshow(image, cmap="binary")
        plt.axis("off")
################
https://github.com/ageron/handson-ml2/blob/master/tools_matplotlib.ipynb
https://github.com/ageron/handson-ml2/blob/master/15_processing_sequences_using_rnns_and_cnns.ipynb

################
model = keras.models.Sequential([
    keras.layers.LSTM(20, return_sequences=True, input_shape=[None, 1]),
    keras.layers.LSTM(20, return_sequences=True),
    keras.layers.TimeDistributed(keras.layers.Dense(10))
])

model.compile(loss="mse", optimizer="adam", metrics=[last_time_step_mse])
history = model.fit(X_train, Y_train, epochs=20,
                    validation_data=(X_valid, Y_valid))
################

def side_by_side(np_iter, label_iter, start=0, stop=None):
    rcParams['figure.figsize'] = [15, 5]
    assert np_iter[0].shape == np_iter[1].shape
    stop = len(np_iter[0]) if not stop else stop
    if label_iter:
        assert len(np_iter) == len(label_iter)
    
    plt.clf()
    palette=sns.color_palette("flare", as_cmap=False)
    sns.set_theme(style="darkgrid", color_codes=True, palette=palette)
    
    if label_iter:
        h_axis = [i for i in range(len(np_iter[0][start:stop]))]
        for i, arr in enumerate(np_iter):   
            plt.plot(h_axis, arr[start:stop], color=palette[i], linestyle='-')
        plt.legend(labels=label_iter)
    else:
        for i, arr in enumerate(np_iter):   
            plt.plot(h_axis, arr[start:stop], color=palette[i], linestyle='-')
            
    plt.show()

